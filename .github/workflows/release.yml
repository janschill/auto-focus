name: Release

on:
  push:
    branches:
      - main
    paths-ignore:
      - ".github/workflows/release.yml"
      - "docs/downloads/**"
      - "README.md"
      - "*.md"
  workflow_dispatch: # Allow manual triggering for testing

jobs:
  release:
    name: Build, Sign, Notarize, and Release
    runs-on: macos-15
    timeout-minutes: 60

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history needed for git tags
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch all tags
        run: |
          git fetch --tags --force
          echo "‚úÖ Fetched all tags"

      - name: Select Xcode version
        run: sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer

      - name: Cache Swift packages
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Developer/Xcode/DerivedData
            .build
          key: ${{ runner.os }}-swift-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-swift-

      - name: Resolve package dependencies
        run: xcodebuild -resolvePackageDependencies -project auto-focus.xcodeproj

      - name: Import code signing certificate
        uses: apple-actions/import-codesign-certs@v2
        id: import-certs
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE }}
          p12-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

      - name: Verify certificate import
        run: |
          echo "Available signing identities:"
          security find-identity -v -p codesigning

          # Check specifically for Developer ID Application
          if ! security find-identity -v -p codesigning | grep -q "Developer ID Application"; then
            echo "‚ùå Developer ID Application certificate not found"
            echo "All identities:"
            security find-identity -v -p codesigning
            exit 1
          fi

          echo "‚úÖ Certificate verified"

      - name: Calculate next version
        id: version
        run: |
          # First, try to read MARKETING_VERSION from project file
          PROJECT_VERSION=$(grep -m 1 "MARKETING_VERSION = " auto-focus.xcodeproj/project.pbxproj | sed 's/.*MARKETING_VERSION = \([^;]*\);.*/\1/' | head -n 1)

          # Get latest tag matching v1.*.* pattern
          LATEST_TAG=$(git tag -l "v1.*.*" --sort=-version:refname | head -n 1)

          if [ -z "$LATEST_TAG" ]; then
            # No existing tag, use project version or start at v1.0.0
            if [ -n "$PROJECT_VERSION" ] && [ "$PROJECT_VERSION" != "1.0" ]; then
              NEW_VERSION="$PROJECT_VERSION"
              echo "No existing tag found, using MARKETING_VERSION from project: $NEW_VERSION"
            else
              NEW_VERSION="1.0.0"
              echo "No existing tag found, starting at v1.0.0"
            fi
          else
            # Extract version number from tag (remove 'v' prefix)
            TAG_VERSION=${LATEST_TAG#v}

            # Compare project version with tag version
            if [ -n "$PROJECT_VERSION" ] && [ "$PROJECT_VERSION" != "1.0" ]; then
              # Use the higher of the two versions
              if [ "$(printf '%s\n' "$PROJECT_VERSION" "$TAG_VERSION" | sort -V | tail -n 1)" = "$PROJECT_VERSION" ]; then
                NEW_VERSION="$PROJECT_VERSION"
                echo "Using MARKETING_VERSION from project ($NEW_VERSION) as it's newer than latest tag ($TAG_VERSION)"
              else
                # Tag is newer, increment patch
                IFS='.' read -ra VERSION_PARTS <<< "$TAG_VERSION"
                MAJOR=${VERSION_PARTS[0]:-1}
                MINOR=${VERSION_PARTS[1]:-0}
                PATCH=${VERSION_PARTS[2]:-0}
                PATCH=$((PATCH + 1))
                NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
                echo "Latest tag ($TAG_VERSION) is newer, incrementing patch: $TAG_VERSION -> $NEW_VERSION"
              fi
            else
              # No project version or it's 1.0, increment from tag
              IFS='.' read -ra VERSION_PARTS <<< "$TAG_VERSION"
              MAJOR=${VERSION_PARTS[0]:-1}
              MINOR=${VERSION_PARTS[1]:-0}
              PATCH=${VERSION_PARTS[2]:-0}
              PATCH=$((PATCH + 1))
              NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
              echo "Latest tag: $LATEST_TAG"
              echo "Incrementing patch: $TAG_VERSION -> $NEW_VERSION"
            fi
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEW_VERSION"

      - name: Update Xcode project version
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Update MARKETING_VERSION in project.pbxproj (handles multiple occurrences)
          # Use a more specific pattern to avoid matching other version strings
          sed -i.bak "s/MARKETING_VERSION = [^;]*;/MARKETING_VERSION = $VERSION;/g" auto-focus.xcodeproj/project.pbxproj
          rm -f auto-focus.xcodeproj/project.pbxproj.bak

          # Verify the update
          if grep -q "MARKETING_VERSION = $VERSION" auto-focus.xcodeproj/project.pbxproj; then
            echo "‚úÖ Updated MARKETING_VERSION to $VERSION"
          else
            echo "‚ùå Failed to update MARKETING_VERSION"
            exit 1
          fi

      - name: Build and archive app
        env:
          HMAC_SECRET: ${{ secrets.HMAC_SECRET }}
        run: |
          # List available certificates for debugging
          echo "Checking for signing certificate before build..."
          security find-identity -v -p codesigning | grep "Developer ID Application" || echo "Warning: Certificate not found"

          xcodebuild clean archive \
            -project auto-focus.xcodeproj \
            -scheme auto-focus \
            -configuration Release \
            -archivePath build/auto-focus.xcarchive \
            -derivedDataPath build/DerivedData \
            CODE_SIGN_IDENTITY="Developer ID Application: Jan Schill (LKQJ2JG34Y)" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM=LKQJ2JG34Y \
            HMAC_SECRET="$HMAC_SECRET" || exit $?

      - name: Extract app from archive
        run: |
          mkdir -p build
          cp -R build/auto-focus.xcarchive/Products/Applications/auto-focus.app build/auto-focus_temp.app
          echo "App extracted to build/auto-focus_temp.app"

      - name: Code sign app
        run: |
          codesign --sign "Developer ID Application: Jan Schill (LKQJ2JG34Y)" \
            --timestamp \
            --options runtime \
            --deep \
            --force \
            build/auto-focus_temp.app

          # Verify signature
          codesign --verify --verbose build/auto-focus_temp.app
          echo "‚úÖ Code signing verified"

      - name: Create ZIP for notarization
        run: |
          cd build
          zip -r auto-focus_notarization.zip auto-focus_temp.app
          echo "Created notarization ZIP"

      - name: Notarize app
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Submit for notarization
          xcrun notarytool submit build/auto-focus_notarization.zip \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait

          echo "‚úÖ Notarization successful"

      - name: Staple notarization ticket
        run: |
          xcrun stapler staple build/auto-focus_temp.app
          xcrun stapler validate build/auto-focus_temp.app
          echo "‚úÖ Notarization ticket stapled"

      - name: Package app for distribution
        run: |
          mkdir -p docs/downloads

          # Rename app for distribution (remove _temp suffix)
          cd build
          cp -R auto-focus_temp.app auto-focus.app

          # Create final distribution ZIP
          zip -r ../docs/downloads/Auto-Focus.zip auto-focus.app
          cd ..

          # Verify ZIP contents
          if unzip -l docs/downloads/Auto-Focus.zip | grep -q "auto-focus.app/"; then
            echo "‚úÖ App ZIP created successfully"
          else
            echo "‚ùå ERROR: ZIP does not contain auto-focus.app"
            echo "ZIP contents:"
            unzip -l docs/downloads/Auto-Focus.zip | head -20
            exit 1
          fi

      - name: Package browser extension
        run: |
          mkdir -p docs/downloads
          cd auto-focus-browser-extension
          zip -r ../docs/downloads/auto-focus-extension.zip chrome/ -x "*.DS_Store*" "*/.git*"
          echo "‚úÖ Extension packaged"

      - name: Generate version.json
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          COMMIT_HASH=$(git rev-parse --short HEAD)

          cat > docs/downloads/version.json << EOF
          {
            "version": "$VERSION",
            "build_date": "$BUILD_DATE",
            "commit_hash": "$COMMIT_HASH",
            "app_zip": "Auto-Focus.zip",
            "extension_zip": "auto-focus-extension.zip",
            "download_url": "https://auto-focus.app/downloads/Auto-Focus.zip",
            "min_macos": "14.0"
          }
          EOF

          echo "‚úÖ Version file generated"
          echo "Version: $VERSION"
          echo "Build date: $BUILD_DATE"
          echo "Commit: $COMMIT_HASH"

      - name: Create git tag
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" -m "Release $TAG"
          echo "Created tag: $TAG"

      - name: Commit distribution files
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Remove old files from git tracking (if they exist)
          git rm --cached --ignore-unmatch docs/downloads/*.zip docs/downloads/version.json 2>/dev/null || true

          # Add new distribution files
          git add docs/downloads/Auto-Focus.zip \
                  docs/downloads/auto-focus-extension.zip \
                  docs/downloads/version.json \
                  auto-focus.xcodeproj/project.pbxproj

          # Commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Release ${{ steps.version.outputs.tag }}: Update distribution files"
            echo "‚úÖ Committed distribution files"
          fi

      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          COMMIT_HASH=$(git rev-parse --short HEAD)

          cat > /tmp/release_notes.md << EOF
          ## Auto-Focus $TAG

          ### Release Information
          - **Version**: $VERSION
          - **Build Date**: $BUILD_DATE
          - **Commit**: $COMMIT_HASH

          ### Installation
          1. Download Auto-Focus.zip
          2. Extract and move Auto-Focus.app to Applications
          3. Install the included Shortcut
          4. Launch and configure focus apps

          ### System Requirements
          - macOS Sonoma (14.0) or later
          - Chrome browser (for extension)

          ---

          üîó **Website**: https://auto-focus.app
          EOF

          echo "‚úÖ Release notes generated"

      - name: Create GitHub release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Release ${{ steps.version.outputs.tag }}
          body_path: /tmp/release_notes.md
          files: |
            docs/downloads/Auto-Focus.zip
            docs/downloads/auto-focus-extension.zip
            docs/downloads/version.json
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Push tag and commits
        run: |
          TAG="${{ steps.version.outputs.tag }}"

          # Push tag first
          git push origin "$TAG" || echo "Tag may already exist"

          # Check if there are commits to push
          if git diff --quiet HEAD origin/main 2>/dev/null; then
            echo "No new commits to push"
          else
            git push origin main
            echo "‚úÖ Pushed commits to main"
          fi

      - name: Cleanup
        if: always()
        run: |
          # The apple-actions/import-codesign-certs action handles cleanup automatically
          echo "‚úÖ Cleanup complete"
